# Commit Context Explorer - Strategic Roadmap

**Created**: 2025-12-09
**Product Vision**: Be the single source of truth for deployment context - "What shipped, why, and with what impact?"

---

## Product Analysis

### Core Value Proposition

The Commit Context Explorer aggregates deployment intelligence from multiple sources (GitHub, Jira, Sentry, Honeycomb) into a single unified view. For developers and engineering managers, this eliminates context-switching between 5+ tools when investigating deployments, incidents, or feature rollouts.

### Current State (Phase 1 - Complete)

- **GitHub Integration**: Commit details, PR information, deployment status via GitHub Actions
- **Changelog Generation**: AI-powered summaries comparing commit ranges
- **Mach-Config Analysis**: Parses component version changes in deployment configs
- **Ticket Extraction**: Extracts `PX-XXX` ticket references from commit messages

### Target Users

1. **Developers**: "What's in this deploy? Did it succeed?"
2. **Engineering Managers**: "What shipped this week? What's the risk?"
3. **On-Call Engineers**: "What recently deployed that might be causing this incident?"
4. **Product Managers**: "Is my feature live? Where can I find the changelog?"

---

## Strategic Themes

### Theme 1: Observability Correlation (High Impact)

**Why**: The highest-value feature gap - connecting deployments to their downstream impact

- Sentry integration: Show errors introduced/resolved per deployment
- Honeycomb integration: Link deploys to performance metrics

**Impact**: Transforms tool from "deployment lookup" to "deployment impact analysis"

### Theme 2: Work Item Context (Medium Impact)

**Why**: Ticket references are already extracted but provide no context

- Jira integration: Enrich PX-XXX tickets with status, assignee, description
- Link tickets bidirectionally (commit → ticket, ticket → deployments)

**Impact**: Creates full traceability from business requirement to production

### Theme 3: UX Refinement (Foundation)

**Why**: Current single-page design limits use cases

- Deep linking to specific commits/changelogs/deployments
- Keyboard navigation for power users
- Quick access to recent searches
- Browser notifications for deployment completion

**Impact**: Improves daily workflow integration

### Theme 4: Team Intelligence (Future Vision)

**Why**: Aggregate data unlocks insights

- Deployment frequency metrics
- DORA metrics visualization
- Team activity patterns
- Release velocity tracking

**Impact**: Engineering leadership dashboard

---

## Prioritized Roadmap

### NOW (Phase 2 - Sentry Integration)

**Strategic rationale**: Error correlation is the "killer feature" - answers "did this deploy break anything?"

1. **Sentry Issue Correlation** - Show issues first seen after deployment
2. **Error Rate Delta** - Compare error rates before/after deploy
3. **Release Health Dashboard** - Crash-free sessions, unhandled exceptions
4. **Issue Linking** - Deep links from commit view to Sentry issues

**Dependencies**: Sentry API token, release tracking configured in target repos

### NEXT (Phase 3 - Jira Integration)

**Strategic rationale**: Completes the "why" story - from ticket to production

1. **Ticket Enrichment** - Display status, assignee, description for PX-XXX refs
2. **Ticket→Deploy Lookup** - Enter ticket ID, see all related deployments
3. **Sprint Context** - Show which sprint/version a commit belongs to
4. **Acceptance Criteria** - Display ticket AC alongside deployment

**Dependencies**: Jira API access, ticket ID pattern configuration

### FUTURE (Phase 4 - Honeycomb Integration)

**Strategic rationale**: Performance impact is the final piece of deployment context

1. **Performance Delta** - P50/P95 latency before/after deploy
2. **Query Correlation** - Link to Honeycomb queries for deployed code paths
3. **SLO Impact** - Show if deployment affected SLO compliance
4. **Trace Examples** - Deep links to example traces post-deployment

**Dependencies**: Honeycomb API token, deployment markers configured

---

## Technical Considerations

### API Integration Pattern

Each integration should follow:

\`\`\`
/api/{integration}/route.ts  → Backend API route
lib/{integration}.ts         → API client + types
components/{integration}/    → UI components
\`\`\`

### Environment Variables

\`\`\`bash
GITHUB_TOKEN=        # Current
SENTRY_AUTH_TOKEN=   # Phase 2
SENTRY_ORG=          # Phase 2
JIRA_API_TOKEN=      # Phase 3
JIRA_BASE_URL=       # Phase 3
HONEYCOMB_API_KEY=   # Phase 4
\`\`\`

### Caching Strategy

- SWR client-side caching (current)
- Consider server-side caching for expensive Sentry/Honeycomb queries
- Redis or Vercel KV for production

---

## Success Metrics

1. **Adoption**: Daily active users within engineering team
2. **Time Saved**: Survey - time to find deployment context before vs. after
3. **Incident Response**: Time to correlate deploys with incidents
4. **Feature Completeness**: % of deployment questions answerable in-tool

---

## Questions for Product Direction

1. **Sentry Scope**: All projects or specific FrasersGroup repos?
2. **Jira Instance**: Which Jira instance(s) contain PX-XXX tickets?
3. **Honeycomb Datasets**: Which datasets should be queryable?
4. **Auth Model**: Will this be internal-only or need auth layer?
5. **Multi-repo**: Support for repositories beyond FrasersGroup/website?

---

## Next Steps

1. Create GitHub issues for Phase 2 (Sentry) features
2. Validate Sentry API access and required scopes
3. Design Sentry UI components (error cards, charts)
4. Implement Sentry integration in /api/sentry/route.ts
